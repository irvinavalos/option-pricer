import numpy as np
from scipy.stats import norm

from bspx.instruments import Greeks
from bspx.pricing import calculate_d1_d2, d1
from bspx.types import ArrayLike


def _delta_call_d1(
    S: ArrayLike,
    K: ArrayLike,
    T: ArrayLike,
    r: ArrayLike,
    vol: ArrayLike,
    _d1: ArrayLike | None,
) -> ArrayLike:
    if _d1 is None:
        _d1 = d1(S, K, T, r, vol)
    return norm.cdf(_d1)


def delta_call(
    S: ArrayLike,
    K: ArrayLike,
    T: ArrayLike,
    r: ArrayLike,
    vol: ArrayLike,
) -> ArrayLike:
    return _delta_call_d1(S, K, T, r, vol, _d1=None)

def _delta_put_d1(
    S: ArrayLike,
    K: ArrayLike,
    T: ArrayLike,
    r: ArrayLike,
    vol: ArrayLike,
    _d1: ArrayLike | None,
) -> ArrayLike:
    if _d1 is None:
        _d1 = d1(S, K, T, r, vol)
    return norm.cdf(_d1) - 1


def delta_put(
    S: ArrayLike,
    K: ArrayLike,
    T: ArrayLike,
    r: ArrayLike,
    vol: ArrayLike,
) -> ArrayLike:
    return _delta_put_d1(S, K, T, r, vol, _d1=None)


def theta_call(
    S: ArrayLike,
    K: ArrayLike,
    T: ArrayLike,
    r: ArrayLike,
    vol: ArrayLike,
) -> ArrayLike:
    d1, d2 = calculate_d1_d2(S, K, T, r, vol)
    return (-S * norm.pdf(d1) * vol / np.sqrt(4 * T)) - (
        r * K * np.exp(-r * T) * norm.cdf(d2)
    )


def theta_put(
    S: ArrayLike,
    K: ArrayLike,
    T: ArrayLike,
    r: ArrayLike,
    vol: ArrayLike,
) -> ArrayLike:
    d1, d2 = calculate_d1_d2(S, K, T, r, vol)
    return (-S * norm.pdf(d1) * vol / np.sqrt(4 * T)) + (
        r * K * np.exp(-r * T) * norm.cdf(-d2)
    )


def calculate_greeks(
    S: ArrayLike, K: ArrayLike, T: ArrayLike, r: ArrayLike, vol: ArrayLike
) -> Greeks: ...
